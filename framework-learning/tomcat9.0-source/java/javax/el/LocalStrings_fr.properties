# Licensed to the Apache Software Foundation (ASF) under one or more
# contributor license agreements.  See the NOTICE file distributed with
# this work for additional information regarding copyright ownership.
# The ASF licenses this file to You under the Apache License, Version 2.0
# (the "License"); you may not use this file except in compliance with
# the License.  You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

beanNameELResolver.beanReadOnly=Le nom de bean [{0}] est en lecture seule

elProcessor.defineFunctionInvalidClass=La classe [{0}] n''est pas publique
elProcessor.defineFunctionInvalidMethod=La m\u00E9thode [{0}] sur la classe [{1}] n''est pas une m\u00E9thode statique publique
elProcessor.defineFunctionInvalidParameterList=La liste de param\u00E8tres [{0}] pour la m\u00E9thode [{1}] de la classe [{2}] n''est pas valide
elProcessor.defineFunctionInvalidParameterTypeName=Le type [{0}] du param\u00E8tre de la m\u00E9thode [{1}] sur la classe [{2}] n''est pas valide
elProcessor.defineFunctionNoMethod=Une m\u00E9thode statique et publique [{0}] n''a pas pu \u00EAtre trouv\u00E9e sur la classe [{1}]
elProcessor.defineFunctionNullParams=On ou plusieurs param\u00E8tres d'entr\u00E9e sont null

expressionFactory.cannotCreate=Impossible de cr\u00E9er une ExpressionFactory de type [{0}]
expressionFactory.cannotFind=Impossible de trouver une ExpressionFactory de type [{0}]
expressionFactory.readFailed=Impossible de lire [{0}]

importHandler.ambiguousImport=La classe [{0}] n''a pas pu \u00EAtre import\u00E9e car elle entre en conflit avec [{1}] qui a d\u00E9j\u00E0 \u00E9t\u00E9 import\u00E9e
importHandler.ambiguousStaticImport=L''import statique [{0}] ne peut pas \u00EAtre trait\u00E9 parce qu''il est en conflit avec [{1}] qui a d\u00E9j\u00E0 \u00E9t\u00E9 import\u00E9
importHandler.classNotFound=La classe [{0}] n''a pu \u00EAtre import\u00E9e, vu qu''on ne l''a pas trouv\u00E9e
importHandler.invalidClass=La classe [{0}] doit \u00EAtre publique, non abstraite, ne pas \u00EAtre une interface et (pour Java 9+) \u00EAtre dans un package export\u00E9
importHandler.invalidClassName=Le nom de la classe \u00E0 importer [{0}] doit comprendre un paquet
importHandler.invalidClassNameForStatic=La classe [{0}] sp\u00E9cifi\u00E9e pour l''import statique [{1}] n''est pas valide
importHandler.invalidStaticName=Le nom de la m\u00E9thode statique ou champ \u00E0 importer [{0}] doit inclure une calsse
importHandler.staticNotFound=L''importation statique [{0}] n''a pas \u00E9t\u00E9 trouv\u00E9e dans la classe [{1}] pour [{2}]

lambdaExpression.tooFewArgs=Seuls [{0}] arguments ont \u00E9t\u00E9 fournis pour une expression lambdaDemo qui en demande au moins [{1}]

objectNotAssignable=Impossible d''ajouter un objet du type [{0}] \u00E0 un tableau d''objets de type [{1}]
propertyNotFound=La propri\u00E9t\u00E9 [{1}] n''a pas \u00E9t\u00E9 trouv\u00E9e sur le type [{0}]
propertyNotReadable=La propri\u00E9t\u00E9 [{1}] n''est pas lisible sur le type [{0}]
propertyNotWritable=La propri\u00E9t\u00E9 [{1}] ne peut pas \u00EAtre \u00E9crite pour le type [{0}]
propertyReadError=Erreur lors de la lecture de [{1}] sur le type [{0}]
propertyWriteError=Erreur d''\u00E9criture [{1}] sur le type [{0}]

staticFieldELResolver.methodNotFound=Aucune m\u00E9thode publique et statique nomm\u00E9e [{0}] n''a \u00E9t\u00E9 trouv\u00E9e dans la classe [{1}]
staticFieldELResolver.notFound=Aucun champ public statique nomm\u00E9 [{0}] n''a \u00E9t\u00E9 trouv\u00E9 dans la classe [{1}] (export\u00E9e pour Java 9+)
staticFieldELResolver.notWriteable=L''\u00E9criture dans les champs statiques (champ [{0}] dans la classe [{1}] dans le cas pr\u00E9sent) est interdite

util.method.ambiguous=Impossible de trouver une m\u00E9thode non ambigu\u00EB : {0}.{1}({2})
util.method.notfound=M\u00E9thode non trouv\u00E9e : {0}.{1}({2})
