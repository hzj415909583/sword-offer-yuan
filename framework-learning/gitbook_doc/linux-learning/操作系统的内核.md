<!-- TOC -->

   * [操作系统的内核](#操作系统的内核)
      * [Linux内核](#linux内核)
         * [操作系统的用户态与内核态](#操作系统的用户态与内核态)
            * [为什么要有用户态与内核态?](#为什么要有用户态与内核态)
            * [用户态切换到内核态的几种方式](#用户态切换到内核态的几种方式)
            * [物理内存RAM(Random Access Memory 随机存储器)](#物理内存ramrandom-access-memory-随机存储器)
            * [虚拟内存(Virtual Memory)](#虚拟内存virtual-memory)
            * [Swap交换空间](#swap交换空间)

<!-- /TOC -->


# 操作系统的内核

操作系统的内核是操作系统的核心部分。
它负责系统的内存管理，硬件设备的管理，文件系统的管理以及应用程序的管理。

**图源:
[简书](https://www.jianshu.com/p/85e931636f27) (如有侵权,请联系俺,俺会立刻删除)**

## Linux内核
我们常说的Linux，其实是指基于Linux内核开发的操作系统。
常见的Linux系统发行版有:Debian,RedHat,Ubuntu,Suse,Centeos等等。

### 操作系统的用户态与内核态

unix与linux的体系架构：分为用户态与内核态。
用户态与内核态与内核态是操作系统对执行权限进行分级后的不同的运行模式。

![用户态与内核态](../../img/jdk-jvm-juc/用户态与内核态.png)

#### 为什么要有用户态与内核态?
在cpu的所有指令中，有些指令是非常危险的，如果使用不当，将会造成系统崩溃等后果。
为了避免这种情况发生，cpu将指令划分为**特权级(内核态)指令**和**非特权级(用户态)指令。**

**对于那些危险的指令只允许内核及其相关模块调用，对于那些不会造成危险的指令，就允许用户应用程序调用。**

* 内核态(核心态,特权态): **内核态是操作系统内核运行的模式。**
内核态控制计算机的硬件资源，如硬件设备，文件系统等等，并为上层应用程序提供执行环境。

* 用户态: **用户态是用户应用程序运行的状态。**
应用程序必须依托于内核态运行,因此用户态的态的操作权限比内核态是要低的，
如磁盘，文件等，访问操作都是受限的。

* 系统调用: 系统调用是操作系统为应用程序提供能够访问到内核态的资源的接口。

#### 用户态切换到内核态的几种方式
* 系统调用: 系统调用是用户态主动要求切换到内核态的一种方式，
用户应用程序通过操作系统调用内核为上层应用程序开放的接口来执行程序。

* 异常: 当cpu在执行用户态的应用程序时，发生了某些不可知的异常。
于是当前用户态的应用进程切换到处理此异常的内核的程序中去。

* 硬件设备的中断: 当硬件设备完成用户请求后，会向cpu发出相应的中断信号，
这时cpu会暂停执行下一条即将要执行的指令，转而去执行与中断信号对应的应用程序，
如果先前执行的指令是用户态下程序的指令，那么这个转换过程也是用户态到内核台的转换。

#### 物理内存RAM(Random Access Memory 随机存储器)
物理内存是计算机的实际内存大小，它直接与CPU交换数据，也被称为主存。

#### 虚拟内存(Virtual Memory)
**虚拟内存是操作系统为了更高效率使用物理内存的一种概念，它是对物理内存的抽象。**
windows上的虚拟内存和Linux上的swap交换空间都是虚拟内存的一种实现技术。

#### Swap交换空间
简单理解: 当某个应用程序所需的内存空间不够了，
那么系统会判断当前物理内存是否还有足够的空闲可以分配给应用程序。
如果有，则应用程序直接进入内存运行；如果没有，系统就根据某种算法(如:LRU)挂起一个进程，
将挂起的进程交换到虚拟内存Swap中等待，并将应用程序调入内存执行。
虚拟内存是被虚拟出来的，可以使用硬盘(不仅仅是硬盘)来作为虚拟内存。

这就是为什么当我们运行一个所需内存比我们计算机内存还大的程序时，仍然可以正常运行，并感受不到内存的限制的原因。